#include <ArduinoOTA.h>
#include <Arduino_MQTT_Client.h>
#include <ArduinoHttpClient.h>
#include <Adafruit_Sensor.h>
#include <ThingsBoard.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <DHT.h>
#include <DHT_U.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <array>


// ƒê·ªãa ch·ªâ I2C c·ªßa m√†n h√¨nh LCD
#define LCD_ADDR 0x27
#define LCD_COLS 16
#define LCD_ROWS 2
#define SDA_PIN 21 // SDA - GPIO 21
#define SCL_PIN 22 // SCL - GPIO 22


// ƒê·ªãnh nghƒ©a ch√¢n k·∫øt n·ªëi
#define LED_PIN 2 // Ch√¢n k·∫øt n·ªëi LED
#define LED_BUTTON_PIN 33 // Button LED
#define DHT_PIN 14  // Ch√¢n k·∫øt n·ªëi c·∫£m bi·∫øn nhi·ªát ƒë·ªô ƒë·ªô ·∫©m DHT11
#define SOIL_MOISTURE_PIN 34  // Ch√¢n k·∫øt n·ªëi c·∫£m bi·∫øn ƒë·ªô ·∫©m ƒë·∫•t
#define RELAY_PIN 26       // Relay
#define BUTTON_PIN 16      // Button Pump
#define MODE_BUTTON_PIN 17 // Button Auto/Manual mode


// C·∫•u h√¨nh WiFi
// constexpr char WIFI_SSID[] = "E11_12";
// constexpr char WIFI_PASSWORD[] = "Tiger@E1112";

constexpr char WIFI_SSID[] = "GGROUP-LAU5";
constexpr char WIFI_PASSWORD[] = "Ggr0up5#";


// Telegram Bot
#define TELEGRAM_BOT_TOKEN "8122936180:AAHVsRVDZrjwevWBwJnzZOHm_dgcJgkevuY"
#define TELEGRAM_CHAT_ID "1378242143"


// C·∫•u h√¨nh ThingsBoard
constexpr char TOKEN[] = "snd4dtdskqneltfh76yk";
constexpr char THINGSBOARD_SERVER[] = "app.coreiot.io";
constexpr uint16_t THINGSBOARD_PORT = 1883U;


// C√°c h·∫±ng s·ªë c·∫•u h√¨nh
constexpr uint32_t MAX_MESSAGE_SIZE = 1024U;
constexpr uint32_t SERIAL_DEBUG_BAUD = 115200U;
constexpr uint16_t reconnectInterval = 180000U; // 3 ph√∫t
constexpr int16_t telemetrySendInterval = 10000U; // 10 gi√¢y
constexpr uint32_t alertInterval = 600000; // 10 ph√∫t (600.000 milliseconds)


// C√°c thu·ªôc t√≠nh ThingsBoard
constexpr char LED_STATE_ATTR[] = "ledState";


// C√°c bi·∫øn tr·∫°ng th√°i
volatile bool attributesChanged = false;
volatile bool ledState = false;   // Tr·∫°ng th√°i c·ªßa LED
bool lastLedButtonState = HIGH;  // Tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥ c·ªßa n√∫t nh·∫•n
bool isAutoMode = true;         // Auto Mode
bool pumpState = false;        // Tr·∫°ng th√°i c·ªßa Pump

// Semaphore b·∫£o v·ªá bi·∫øn ledState
SemaphoreHandle_t ledSemaphore;

// L∆∞u th·ªùi ƒëi·ªÉm g·ª≠i d·ªØ li·ªáu v√† ki·ªÉm tra k·∫øt n·ªëi
uint32_t previousDataSend;
uint32_t previousReconnectCheck;
uint32_t lastAlertTime = 0;

constexpr std::array<const char *, 1U> SHARED_ATTRIBUTES_LIST = {
  LED_STATE_ATTR
};


// Kh·ªüi t·∫°o c√°c ƒë·ªëi t∆∞·ª£ng
WiFiClient wifiClient;
Arduino_MQTT_Client mqttClient(wifiClient);
ThingsBoard tb(mqttClient, MAX_MESSAGE_SIZE);
DHT dht(DHT_PIN, DHT11);
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);


// To·∫° ƒë·ªô GPS c·ªßa thi·∫øt b·ªã
constexpr float latitude = 10.898576;
constexpr float longitude = 106.794645;


// G·ª≠i tin nh·∫Øn c·∫£nh b√°o qua Telegram
void sendTelegramMessage(String message, String imageUrl) {
  String url = "https://api.telegram.org/bot" + String(TELEGRAM_BOT_TOKEN) + 
              "/sendPhoto?chat_id=" + String(TELEGRAM_CHAT_ID) + 
              "&photo=" + imageUrl + 
              "&caption=" + message;

  HTTPClient http;
  http.begin(url);
  int httpResponseCode = http.GET();

  if (httpResponseCode > 0) {
    Serial.println("G·ª≠i tin nh·∫Øn Telegram th√†nh c√¥ng!");
  } else {
    Serial.print("L·ªói g·ª≠i tin nh·∫Øn Telegram");
    Serial.println(httpResponseCode);
  }
  http.end();
}

void checkAndSendAlerts(float humidity, float temperature, float soilMoisturePercent) {
  uint32_t currentMillis = millis();

  String ImageURL = "http://rangdong.com.vn/uploads/news/tin-san-pham/nguoi-ban-4.0-cua-nha-nong/smart-farm-rang-dong-nguoi-ban-4.0-cua-nha-nong-5.jpg";

  // Ch·ªâ g·ª≠i c·∫£nh b√°o n·∫øu ƒë√£ ƒë·ªß 10 ph√∫t k·ªÉ t·ª´ l·∫ßn g·ª≠i tr∆∞·ªõc
  if (currentMillis - lastAlertTime >= alertInterval) {
    bool alertSent = false;

    String alertMessage = "üö® **C·∫£nh b√°o Smart Farm** üö® %0A";
    // G·ª≠i c·∫£nh b√°o ƒê·ªô ·∫©m qua Telegram
    if (humidity < 30) {
      alertMessage += "üå´ ƒê·ªô ·∫©m qu√° th·∫•p! (üìâ " + String(humidity) + "%) %0A";
      alertSent = true;
    }  else if (humidity > 80) {
      alertMessage += "üå´ ƒê·ªô ·∫©m qu√° cao! (üìà " + String(humidity) + "%) %0A";
      alertSent = true;
    }
    // G·ª≠i c·∫£nh b√°o Nhi·ªát ƒë·ªô qua Telegram
    if (temperature < 20) {
      alertMessage += "üå°Ô∏è Nhi·ªát ƒë·ªô qu√° th·∫•p! (" + String(temperature) + "¬∞C) %0A";
      alertSent = true;
    } else if (temperature > 35) {
      alertMessage += "üå°Ô∏è Nhi·ªát ƒë·ªô qu√° cao! (" + String(temperature) + "¬∞C) %0A";
      alertSent = true;
    }
    // G·ª≠i c·∫£nh b√°o ƒê·ªô ·∫©m ƒë·∫•t qua Telegram
    if (soilMoisturePercent < 60) {
      alertMessage += "üå± ƒê·ªô ·∫©m ƒë·∫•t th·∫•p! (üíß " + String(soilMoisturePercent) + "%) %0A";
      alertSent = true;
    } else if (soilMoisturePercent > 80) {
      alertMessage += "üå± ƒê·ªô ·∫©m ƒë·∫•t cao! (üíß " + String(soilMoisturePercent) + "%) %0A";
      alertSent = true;
    }

    sendTelegramMessage(alertMessage, ImageURL);


    // N·∫øu c√≥ c·∫£nh b√°o ƒë∆∞·ª£c g·ª≠i, c·∫≠p nh·∫≠t l·∫°i th·ªùi gian g·ª≠i cu·ªëi c√πng
    if (alertSent) {
      lastAlertTime = currentMillis;
    }
  }
}

// X·ª≠ l√Ω RPC t·ª´ Dashboard ƒë·ªÉ thay ƒë·ªïi LED
RPC_Response setLedSwitchState(const RPC_Data &data) {
  bool newLEDState = data;
  xSemaphoreTake(ledSemaphore, portMAX_DELAY);
  ledState = newLEDState;
  digitalWrite(LED_PIN, ledState);
  xSemaphoreGive(ledSemaphore);
  
  Serial.print("Dashboard y√™u c·∫ßu: ");
  Serial.println(ledState ? "B·∫¨T LED!" : "T·∫ÆT LED!");
  attributesChanged = true;
  return RPC_Response("setValueButtonLED", ledState);
}

// RPC ƒë·ªÉ Dashboard l·∫•y tr·∫°ng th√°i LED
RPC_Response getLedState(const RPC_Data &data) {
  return RPC_Response("getValueButtonLED", ledState);
}

RPC_Response setPumpState(const RPC_Data &data) {
  Serial.println("Nh·∫≠n y√™u c·∫ßu thay ƒë·ªïi tr·∫°ng th√°i M√°y b∆°m t·ª´ Dashboard");
  
  bool newState = data; // Nh·∫≠n tr·∫°ng th√°i mong mu·ªën t·ª´ Dashboard

  if (newState) { // B·∫≠t b∆°m t·ª´ Dashboard
    if (isAutoMode) { // N·∫øu ƒëang Auto mode, chuy·ªÉn sang Manual mode
      isAutoMode = false;
      Serial.println("Chuy·ªÉn sang Manual mode");
    }
    pumpState = true;
  } else { // T·∫Øt b∆°m t·ª´ Dashboard
    pumpState = false;
    if (!isAutoMode) {
      Serial.println("T·∫Øt b∆°m! M√°y b∆°m ƒëang ·ªü Manual mode");
    } else {
      isAutoMode = true; // N·∫øu ƒëang ·ªü Auto mode, quay l·∫°i Auto mode
      Serial.println("T·∫Øt b∆°m & quay l·∫°i Auto mode");
    }
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i b∆°m v√† relay
  digitalWrite(RELAY_PIN, pumpState);
  
  Serial.print("M√°y b∆°m: ");
  Serial.println(pumpState ? "B·∫¨T!" : "T·∫ÆT!");

  // G·ª≠i tr·∫°ng th√°i m·ªõi l√™n ThingsBoard ƒë·ªÉ ƒë·ªìng b·ªô
  tb.sendAttributeData("getValueButtonPump", pumpState);

  return RPC_Response("setValueButtonPump", pumpState);
}

RPC_Response getPumpState(const RPC_Data &data) {
  Serial.println("Y√™u c·∫ßu l·∫•y tr·∫°ng th√°i M√°y b∆°m");

  return RPC_Response("getValueButtonPump", pumpState);
}

// M·∫£ng ch·ª©a callback RPC
const std::array<RPC_Callback, 4U> callbacks = {
  RPC_Callback{ "setValueButtonLED", setLedSwitchState },
  RPC_Callback{ "getValueButtonLED", getLedState },
  RPC_Callback{ "setValueButtonPump", setPumpState },  
  RPC_Callback{ "getValueButtonPump", getPumpState }
};


// Prototype c√°c task c·ªßa FreeRTOS
void WiFiTask(void *pvParameters);
void ThingsBoardTask(void *pvParameters);
void ReconnectTask(void *pvParameters);
void SensorTask(void *pvParameters);
void TaskButtonLEDControl(void *pvParameters);
void TaskSendLEDState(void *pvParameters);
void TaskPumpControl(void *pvParameters);
void TaskButtonPumpControl(void *pvParameters);
void TaskModeControl(void *pvParameters);


// H√†m setup
void setup() {
  Serial.begin(SERIAL_DEBUG_BAUD);

  pinMode(LED_PIN, OUTPUT);
  pinMode(LED_BUTTON_PIN, INPUT_PULLUP);

  // Kh·ªüi t·∫°o Semaphore
  ledSemaphore = xSemaphoreCreateMutex();

  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(MODE_BUTTON_PIN, INPUT_PULLUP);

  dht.begin();

  // Kh·ªüi t·∫°o LCD
  Wire.begin(SDA_PIN, SCL_PIN);
  lcd.init();
  lcd.backlight();  // B·∫≠t ƒë√®n n·ªÅn
  lcd.setCursor(0, 0);
  lcd.print("Smart Farm!");
  lcd.setCursor(0, 1);
  lcd.print("Starting...");

  // Kh·ªüi t·∫°o c√°c task c·ªßa FreeRTOS
  xTaskCreate(WiFiTask, "WiFiTask", 4096, NULL, 1, NULL);
  xTaskCreate(ThingsBoardTask, "ThingsBoardTask", 4096, NULL, 1, NULL);
  xTaskCreate(SensorTask, "SensorTask", 4096, NULL, 1, NULL);
  xTaskCreate(ReconnectTask, "ReconnectTask", 4096, NULL, 1, NULL);
  xTaskCreate(TaskButtonLEDControl, "TaskButtonLEDControl", 4096, NULL, 1, NULL);
  xTaskCreate(TaskSendLEDState, "TaskSendLEDState", 2048, NULL, 1, NULL);
  xTaskCreate(TaskPumpControl, "TaskPumpControl", 1000, NULL, 1, NULL);
  xTaskCreate(TaskButtonPumpControl, "TaskButtonPumpControl", 4096, NULL, 1, NULL);
  xTaskCreate(TaskModeControl, "TaskModeControl", 4096, NULL, 1, NULL);
}


// Task k·∫øt n·ªëi WiFi
void WiFiTask(void *pvParameters) {
  for (;;) {
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("Connecting to WiFi...");
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      while (WiFi.status() != WL_CONNECTED) {
        vTaskDelay(300 / portTICK_PERIOD_MS);
        Serial.print(".");
      }
      Serial.println("Connected to WiFi");
    }
    vTaskDelay(2000 / portTICK_PERIOD_MS);
  }
}


// Task k·∫øt n·ªëi ThingsBoard
void ThingsBoardTask(void *pvParameters) {
  for (;;) {
    // Ki·ªÉm tra k·∫øt n·ªëi ThingsBoard, n·∫øu ch∆∞a k·∫øt n·ªëi th√¨ th·ª±c hi·ªán k·∫øt n·ªëi
    if (!tb.connected()) {
      Serial.println("Connecting to ThingsBoard...");
      if (tb.connect(THINGSBOARD_SERVER, TOKEN, THINGSBOARD_PORT)) {
        Serial.println("Connected to ThingsBoard");
        // G·ª≠i MAC address v√† ƒëƒÉng k√Ω RPC
        tb.sendAttributeData("macAddress", WiFi.macAddress().c_str());
        tb.RPC_Subscribe(callbacks.cbegin(), callbacks.cend());

        // G·ª≠i tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa m√°y b∆°m ƒë·ªÉ dashboard c·∫≠p nh·∫≠t
        tb.sendAttributeData("ledState", ledState);
        tb.sendAttributeData("pumpState", pumpState);
      }
      else {
        Serial.println("Failed to connect");
      }
    }
    // N·∫øu c√≥ thay ƒë·ªïi thu·ªôc t√≠nh, c·∫≠p nh·∫≠t l√™n ThingsBoard
    if (attributesChanged) {
      attributesChanged = false;
      tb.sendAttributeData("getValueButtonLED", digitalRead(LED_PIN));
      tb.sendAttributeData("getValueButtonPump", pumpState);
    }
    tb.loop();
    vTaskDelay(800 / portTICK_PERIOD_MS);
  }
}


// Task ki·ªÉm tra v√† k·∫øt n·ªëi l·∫°i WiFi v√† ThingsBoard
void ReconnectTask(void *pvParameters) {
  for (;;) {
    if (millis() - previousReconnectCheck > reconnectInterval) {
      previousReconnectCheck = millis();
      if (WiFi.status() != WL_CONNECTED) {
        Serial.println("Reconnecting WiFi...");
        WiFi.disconnect();
        WiFi.reconnect();
      }
      if (!tb.connected()) {
        Serial.println("Reconnecting to ThingsBoard...");
        tb.connect(THINGSBOARD_SERVER, TOKEN, THINGSBOARD_PORT);
      }
    }
    vTaskDelay(reconnectInterval / portTICK_PERIOD_MS);
  }
}


// Task thu th·∫≠p d·ªØ li·ªáu c·∫£m bi·∫øn v√† g·ª≠i telemetry
void SensorTask(void *pvParameters) {
  for (;;) {
    if (millis() - previousDataSend > telemetrySendInterval) {
      previousDataSend = millis();
      
      // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn DHT11
      float temperature = dht.readTemperature();
      float humidity = dht.readHumidity();

      if (isnan(temperature) || isnan(humidity)) {
        vTaskDelay(2000 / portTICK_PERIOD_MS);
        temperature = dht.readTemperature();
        humidity = dht.readHumidity();
      }

      // ƒê·ªçc gi√° tr·ªã ƒë·ªô ·∫©m ƒë·∫•t
      int soilMoistureRaw = analogRead(SOIL_MOISTURE_PIN);
      // ƒê·∫£m b·∫£o gi√° tr·ªã n·∫±m trong kho·∫£ng [0, 4095] r·ªìi m·ªõi map sang % (0 - 100)
      float soilMoisturePercent = map(soilMoistureRaw, 4095, 0, 0, 100);
      
      // In ra d·ªØ li·ªáu v√† hi·ªÉn th·ªã l√™n Serial Monitor
      Serial.printf("Temperature: %.2f¬∞C, Humidity: %.2f%%, Soil Moisture: %.2f%%\n", temperature, humidity, soilMoisturePercent);
      
      // Hi·ªÉn th·ªã d·ªØ li·ªáu l√™n LCD
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.printf("T:%.1fC H:%.1f%%", temperature, humidity);
      lcd.setCursor(0, 1);
      lcd.printf("Soil: %.1f%%", soilMoisturePercent);
      
      // G·ª≠i d·ªØ li·ªáu l√™n ThingsBoard
      if (!isnan(temperature) && !isnan(humidity)) {
        tb.sendTelemetryData("temperature", temperature);
        tb.sendTelemetryData("humidity", humidity);
      }
      tb.sendTelemetryData("soil_moisture", soilMoisturePercent);

      // G·ª≠i d·ªØ li·ªáu GPS l√™n ThingsBoard
      tb.sendTelemetryData("lat", latitude);
      tb.sendTelemetryData("long", longitude);

      Serial.print("Sent GPS Data: Latitude: ");
      Serial.print(latitude);
      Serial.print(", Longitude: ");
      Serial.println(longitude);

      checkAndSendAlerts(humidity, temperature, soilMoisturePercent);
    }
    vTaskDelay(telemetrySendInterval / portTICK_PERIOD_MS);
  }
}


// Task ƒëi·ªÅu khi·ªÉn LED b·∫±ng n√∫t nh·∫•n
void TaskButtonLEDControl(void *pvParameters) {
  bool lastButtonState = digitalRead(LED_BUTTON_PIN);

  for (;;) {
    bool buttonState = digitalRead(LED_BUTTON_PIN);

    if (buttonState == LOW && lastButtonState == HIGH) { // Nh·∫•n n√∫t
      vTaskDelay(50 / portTICK_PERIOD_MS); // Debounce
      if (digitalRead(LED_BUTTON_PIN) == LOW) {  // Ki·ªÉm tra l·∫°i sau debounce

        ledState = !ledState; // ƒê·∫£o tr·∫°ng th√°i LED
        digitalWrite(LED_PIN, ledState);
        Serial.print("ƒê√®n LED: ");
        Serial.println(ledState ? "B·∫¨T!" : "T·∫ÆT!");

        // Ki·ªÉm tra tr∆∞·ªõc khi g·ª≠i d·ªØ li·ªáu l√™n ThingsBoard
        if (tb.connected()) {
          tb.sendAttributeData("getValueButtonLED", ledState);
        }
      }
    }

    lastButtonState = buttonState;
    vTaskDelay(100 / portTICK_PERIOD_MS);  // Tr√°nh CPU qu√° t·∫£i
  }
}

// G·ª≠i tr·∫°ng th√°i LED l√™n Dashboard m·ªói 5 gi√¢y
void TaskSendLEDState(void *pvParameters) {
  for (;;) {
    // Ch·ªâ g·ª≠i d·ªØ li·ªáu l√™n Dashboard khi c√≥ thay ƒë·ªïi tr·∫°ng th√°i LED
    if (tb.connected()) {
      xSemaphoreTake(ledSemaphore, portMAX_DELAY);  // ƒê·ªìng b·ªô v·ªõi TaskReadButton

      static bool lastSentState = ledState;  // L∆∞u tr·∫°ng th√°i LED ƒë√£ g·ª≠i tr∆∞·ªõc ƒë√≥
      if (lastSentState != ledState) {  // Ch·ªâ g·ª≠i khi tr·∫°ng th√°i thay ƒë·ªïi
        tb.sendAttributeData("getValueButtonLED", ledState);  // G·ª≠i tr·∫°ng th√°i LED l√™n Dashboard
        Serial.println("C·∫≠p nh·∫≠t tr·∫°ng th√°i LED l√™n Dashboard!");
        lastSentState = ledState;  // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë√£ g·ª≠i
      }

      xSemaphoreGive(ledSemaphore);  // Gi·∫£i ph√≥ng Semaphore
    }

    vTaskDelay(5000 / portTICK_PERIOD_MS);  // G·ª≠i m·ªói 5 gi√¢y n·∫øu c√≥ thay ƒë·ªïi
  }
}


// H√†m b·∫≠t/t·∫Øt m√°y b∆°m
void turnOnOffPump(int onOff) {
  digitalWrite(RELAY_PIN, onOff);
}

// Task ƒëi·ªÅu khi·ªÉn Pump auto mode
void TaskPumpControl(void *pvParameters) {
  while(1) {
    if (isAutoMode) { // Ch·ªâ ch·∫°y khi ƒëang ·ªü Auto mode
      turnOnOffPump(1); // B·∫≠t Pump
      Serial.println("M√°y b∆°m (Auto): ƒêang b·∫≠t!");
      vTaskDelay(10000 / portTICK_PERIOD_MS); // Ch·ªù 10s
      
      turnOnOffPump(0); // T·∫Øt Pump
      Serial.println("M√°y b∆°m (Auto): ƒêang t·∫Øt!");
      vTaskDelay(3000 / portTICK_PERIOD_MS); // Ch·ªù 3s
    } else {
      vTaskDelay(50 / portTICK_PERIOD_MS); // N·∫øu ·ªü Manual mode th√¨ ch·ªù ng·∫Øn
    }
  }

  tb.sendAttributeData("getValueButtonPump", pumpState);
}

// Task ƒëi·ªÅu khi·ªÉn Pump b·∫±ng n√∫t nh·∫•n
void TaskButtonPumpControl(void *pvParameters) {
  bool lastButtonState = digitalRead(BUTTON_PIN);

  for (;;) {
    bool buttonState = digitalRead(BUTTON_PIN);

    if (buttonState == LOW && lastButtonState == HIGH) { // Nh·∫•n n√∫t
      vTaskDelay(50 / portTICK_PERIOD_MS); // Debounce
      if (digitalRead(BUTTON_PIN) == LOW) {  // Ki·ªÉm tra l·∫°i sau debounce
        
        if (isAutoMode) {
          isAutoMode = false;
          Serial.println("Chuy·ªÉn sang Manual mode");
        }

        pumpState = !pumpState; // ƒê·∫£o tr·∫°ng th√°i m√°y b∆°m
        digitalWrite(RELAY_PIN, pumpState);
        Serial.print("M√°y b∆°m: ");
        Serial.println(pumpState ? "B·∫¨T!" : "T·∫ÆT!");

        // Ki·ªÉm tra tr∆∞·ªõc khi g·ª≠i d·ªØ li·ªáu l√™n ThingsBoard
        if (tb.connected()) {
          tb.sendAttributeData("getValueButtonPump", pumpState);
        }
      }
    }

    lastButtonState = buttonState;
    vTaskDelay(100 / portTICK_PERIOD_MS);  // Tr√°nh CPU qu√° t·∫£i
  }
}


// Task x·ª≠ l√Ω Button chuy·ªÉn ƒë·ªïi Auto/Manual mode
void TaskModeControl(void *pvParameters) {
  bool lastState = HIGH; // Tr·∫°ng th√°i tr∆∞·ªõc c·ªßa button mode
  for (;;) {
    bool currentState = digitalRead(MODE_BUTTON_PIN);
    if (currentState == LOW && lastState == HIGH) { // Button mode ƒë∆∞·ª£c nh·∫•n
      isAutoMode = !isAutoMode; // Chuy·ªÉn ƒë·ªïi mode
      Serial.print("Ch·∫ø ƒë·ªô: ");
      Serial.println(isAutoMode ? "Auto" : "Manual");
    }
    lastState = currentState;
    vTaskDelay(100 / portTICK_PERIOD_MS); // Tr√°nh l·∫∑p l·∫°i nhanh
  }
}

// H√†m loop
void loop() {
  vTaskDelete(NULL);
}